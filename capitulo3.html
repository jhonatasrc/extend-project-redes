<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cap√≠tulo 3: Camada de Transporte</title>
   
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="capitulos.css">
    
</head>
<body>
    
    <header>
        <div class="container">
            <h1>Desvendando as Redes</h1>
            <nav>
                <ul>
                    <li><a href="index.html#inicio">In√≠cio</a></li>
                    <li><a href="index.html#jornada">Nossa Jornada</a></li>
                    <li><a href="index.html#contato">Contato</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main class="container">
       
        <div class="chapter-navigation-buttons">
            <a href="index.html" class="back-button">‚Üê In√≠cio</a>
            <a href="capitulo2.html" class="back-button">‚Üê Cap√≠tulo Anterior</a>
            <a href="capitulo4.html" class="back-button">Pr√≥ximo Cap√≠tulo ‚Üí</a>
        </div>

        
        <section class="chapter-progress">
            <h3>Progresso da Jornada</h3>
            <div class="progress-indicator">
                <a href="capitulo1.html" class="chapter-dot completed" data-chapter="1">1</a>
                <a href="capitulo2.html" class="chapter-dot completed" data-chapter="2">2</a>
                <a href="capitulo3.html" class="chapter-dot completed current-chapter" data-chapter="3">3</a>
                <a href="capitulo4.html" class="chapter-dot" data-chapter="4">4</a>
                <a href="capitulo5.html" class="chapter-dot" data-chapter="5">5</a>
                <a href="capitulo6.html" class="chapter-dot" data-chapter="6">6</a>
                <a href="capitulo7.html" class="chapter-dot" data-chapter="7">7</a>
                <a href="capitulo8.html" class="chapter-dot" data-chapter="8">8</a>
                <a href="capitulo9.html" class="chapter-dot" data-chapter="9">9</a>
            </div>
            <p>Cap√≠tulos conclu√≠dos: <span id="completed-count">3</span> de <span id="total-chapters">9</span></p>
        </section>

        <section id="capitulo-intro" class="chapter-section">
            <h2>Camada de Transporte</h2>
            <p>
                No cap√≠tulo anterior, exploramos a camada de aplica√ß√£o, onde as intera√ß√µes entre usu√°rios e a Internet ganham vida. Agora, vamos descer um degrau na pilha de protocolos e mergulhar na <strong>Camada de Transporte</strong>. Imagine que a camada de aplica√ß√£o √© o aplicativo que voc√™ usa (como um navegador ou e-mail), e a camada de transporte √© o "servi√ßo de entrega" que esses aplicativos utilizam.
            </p>
            <p>
                A principal fun√ß√£o da camada de transporte √© fornecer uma comunica√ß√£o l√≥gica entre <strong>processos</strong> em diferentes sistemas finais. Embora os sistemas finais estejam conectados por uma rede de roteadores (camada de rede), s√£o os processos (seus programas em execu√ß√£o) que realmente querem se comunicar. A camada de transporte estabelece essa comunica√ß√£o "de processo para processo", usando os servi√ßos da camada de rede para mover pacotes entre hospedeiros.
            </p>
            <p>
                Neste cap√≠tulo, vamos focar nos dois principais protocolos da camada de transporte da Internet: o <strong>UDP (User Datagram Protocol)</strong> e o <strong>TCP (Transmission Control Protocol)</strong>. Entenderemos como eles funcionam, suas diferen√ßas cruciais e como cada um se adapta a diferentes tipos de aplica√ß√µes de rede.
            </p>
        </section>

        <section id="introducao-servicos-camada-transporte" class="chapter-section">
            <h3>Introdu√ß√£o e Servi√ßos da Camada de Transporte</h3>
            <p>
                A camada de transporte est√° localizada entre a camada de aplica√ß√£o (que fornece dados para a rede) e a camada de rede (que move os dados entre hospedeiros).
            </p>
            <ul>
                <li>
                    <h4>Multiplexa√ß√£o e Demultiplexa√ß√£o:</h4>
                    <p>
                        No hospedeiro remetente, a camada de transporte coleta mensagens de diferentes processos da camada de aplica√ß√£o, adiciona cabe√ßalhos e passa para a camada de rede. Isso √© a <strong>multiplexa√ß√£o</strong>. No hospedeiro destinat√°rio, a camada de transporte recebe os segmentos da camada de rede e entrega os dados ao processo de aplica√ß√£o correto. Isso √© a <strong>demultiplexa√ß√£o</strong>.
                    </p>
                    <p>
                        Imagine um aeroporto: v√°rios passageiros (processos) chegam para voos diferentes (aplicativos). A equipe do check-in (multiplexa√ß√£o) os direciona para o avi√£o certo. Ao chegar, a equipe de desembarque (demultiplexa√ß√£o) direciona cada passageiro para seu terminal de destino.
                    </p>
                    <p>
                        Como a demultiplexa√ß√£o funciona? Cada segmento de transporte tem campos de <strong>porta de origem</strong> e <strong>porta de destino</strong>. Esses n√∫meros de porta (lembra-se deles do Cap√≠tulo 2?) s√£o usados para identificar o processo de aplica√ß√£o. O hospedeiro de destino usa o endere√ßo IP de destino e o n√∫mero da porta de destino para entregar o segmento ao socket correto, que por sua vez o entrega ao processo correto.
                    </p>
                </li>
                <li>
                    <h4>Transfer√™ncia Confi√°vel de Dados:</h4>
                    <p>
                        A camada de transporte pode fornecer um servi√ßo de transfer√™ncia de dados confi√°vel, mesmo que a camada de rede subjacente n√£o seja confi√°vel (ou seja, possa perder, corromper ou duplicar pacotes). Isso √© crucial para aplica√ß√µes que n√£o toleram perdas, como FTP, HTTP, SMTP e DNS (que usa TCP para transfer√™ncias de grandes zonas, embora use UDP para consultas b√°sicas).
                    </p>
                    <p>
                        A ideia √© usar t√©cnicas como:
                        <ul>
                            <li><strong>Checksums:</strong> Para detectar erros nos bits.</li>
                            <li><strong>Timers:</strong> Para retransmitir dados se n√£o houver confirma√ß√£o em tempo.</li>
                            <li><strong>Sequence Numbers (N√∫meros de Sequ√™ncia):</strong> Para detectar perdas e reordena√ß√µes.</li>
                            <li><strong>Acknowledgements (ACKs - Confirma√ß√µes):</strong> O receptor envia uma mensagem confirmando o recebimento.</li>
                            <li><strong>Negative Acknowledgements (NAKs - Confirma√ß√µes Negativas):</strong> O receptor informa que um dado est√° corrompido ou faltando.</li>
                            <li><strong>Retransmiss√£o:</strong> O remetente envia novamente dados que foram perdidos ou corrompidos.</li>
                        </ul>
                    </p>
                </li>
            </ul>
        </section>

        <section id="protocolo-udp" class="chapter-section">
            <h3>Protocolo UDP (User Datagram Protocol)</h3>
            <p>
                O UDP √© o protocolo de transporte mais simples e r√°pido da Internet. Ele oferece um servi√ßo minimalista, quase um "envio sem pensar".
            </p>
            <ul>
                <li>
                    <h4>N√£o Orientado √† Conex√£o:</h4>
                    <p>
                        N√£o h√° "apresenta√ß√£o" (handshaking) antes de enviar dados. Um processo UDP envia um segmento a outro sem qualquer comunica√ß√£o preliminar ou garantia de que o receptor est√° pronto. √â como jogar uma garrafa com uma mensagem no oceano ‚Äì voc√™ a joga, mas n√£o sabe se ela chegar√°.
                    </p>
                </li>
                <li>
                    <h4>N√£o Confi√°vel:</h4>
                    <p>
                        O UDP n√£o garante a entrega, a ordem ou a aus√™ncia de duplica√ß√£o dos segmentos. Se um segmento UDP for perdido na rede, o UDP n√£o o retransmite. A aplica√ß√£o precisa lidar com a confiabilidade, se necess√°rio.
                    </p>
                </li>
                <li>
                    <h4>Sem Controle de Congestionamento:</h4>
                    <p>
                        O UDP n√£o tenta evitar sobrecarregar a rede. Ele envia os dados na taxa que a aplica√ß√£o quiser, mesmo que isso cause congestionamento e perdas.
                    </p>
                </li>
                <li>
                    <h4>Vantagens do UDP:</h4>
                    <ul>
                        <li><strong>Controle Fino sobre o Que e Quando Enviar:</strong> A aplica√ß√£o tem mais controle direto.</li>
                        <li><strong>Sem Estabelecimento de Conex√£o:</strong> Menor atraso de configura√ß√£o.</li>
                        <li><strong>Sem Manuten√ß√£o de Estado de Conex√£o:</strong> O servidor n√£o precisa alocar recursos para cada cliente, permitindo mais clientes simult√¢neos.</li>
                        <li><strong>Menor Sobrecarga de Cabe√ßalho:</strong> O cabe√ßalho UDP tem apenas 8 bytes, contra 20 bytes (ou mais) do TCP.</li>
                    </ul>
                </li>
                <li>
                    <h4>Aplica√ß√µes T√≠picas do UDP:</h4>
                    <p>
                        Geralmente usado em aplica√ß√µes onde a velocidade e a sensibilidade ao atraso s√£o mais importantes que a confiabilidade total, ou onde a pr√≥pria aplica√ß√£o implementa sua confiabilidade:
                        <ul>
                            <li>Streaming de v√≠deo e √°udio em tempo real (ex: chamadas de VoIP, jogos online) - pequenas perdas s√£o toler√°veis.</li>
                            <li>DNS (consultas de nome, embora use TCP para grandes transfer√™ncias de zona).</li>
                            <li>SNMP (Simple Network Management Protocol).</li>
                        </ul>
                    </p>
                </li>
                <li>
                    <h4>Formato do Segmento UDP:</h4>
                    <p>
                        Um segmento UDP √© muito simples, contendo apenas um cabe√ßalho de 8 bytes, seguido pelos dados da aplica√ß√£o.
                        <pre>
+----------------+----------------+
| Porta de Origem| Porta de Destino|
+----------------+----------------+
| Comprimento   | Checksum       |
+----------------+----------------+
|         Dados da Aplica√ß√£o       |
|                                 |
+---------------------------------+
                        </pre>
                        <ul>
                            <li><strong>Porta de Origem/Destino:</strong> Identificam os processos de aplica√ß√£o.</li>
                            <li><strong>Comprimento:</strong> Tamanho total do segmento UDP em bytes (cabe√ßalho + dados).</li>
                            <li><strong>Checksum:</strong> Usado para detectar erros (bits invertidos) no segmento. √â opcional, mas frequentemente usado. Se um erro for detectado, o UDP pode descartar o segmento ou pass√°-lo para a aplica√ß√£o com um aviso.</li>
                        </ul>
                    </p>
                </li>
            </ul>
        </section>

        <section id="protocolo-tcp" class="chapter-section">
            <h3>Protocolo TCP (Transmission Control Protocol)</h3>
            <p>
                O TCP √© o protocolo de transporte mais complexo e robusto da Internet, oferecendo um servi√ßo de transfer√™ncia de dados confi√°vel e orientado √† conex√£o.
            </p>
            <ul>
                <li>
                    <h4>Orientado √† Conex√£o:</h4>
                    <p>
                        Antes de trocar dados, TCP cliente e servidor devem estabelecer uma conex√£o atrav√©s de uma "apresenta√ß√£o de tr√™s vias" (three-way handshake). Ap√≥s a troca de dados, a conex√£o √© encerrada.
                    </p>
                </li>
                <li>
                    <h4>Transfer√™ncia Confi√°vel de Dados:</h4>
                    <p>
                        O TCP garante que os dados enviados pelo processo remetente sejam entregues ao processo receptor na ordem correta e sem perdas ou corrup√ß√µes. Ele faz isso usando:
                        <ul>
                            <li><strong>N√∫meros de Sequ√™ncia:</strong> Para ordenar os segmentos e detectar segmentos perdidos ou duplicados.</li>
                            <li><strong>Confirma√ß√µes (ACKs):</strong> O receptor envia ACKs para indicar que recebeu segmentos sem erro.</li>
                            <li><strong>Timers (Temporizadores):</strong> O remetente inicia um timer para cada segmento enviado. Se o timer expirar antes de receber um ACK, o segmento √© retransmitido.</li>
                            <li><strong>Checksums:</strong> Para detectar corrup√ß√£o de bits.</li>
                        </ul>
                    </p>
                </li>
                <li>
                    <h4>Controle de Fluxo:</h4>
                    <p>
                        O TCP impede que um remetente r√°pido sobrecarregue um receptor lento. O receptor TCP informa ao remetente o tamanho de seu buffer livre (janela de recep√ß√£o), e o remetente ajusta sua taxa para n√£o exceder a capacidade do receptor.
                    </p>
                </li>
                <li>
                    <h4>Controle de Congestionamento:</h4>
                    <p>
                        O TCP tenta evitar sobrecarregar a rede, ajustando a taxa de transmiss√£o da aplica√ß√£o para evitar o colapso do sistema de comuta√ß√£o de pacotes. Se o TCP detecta congestionamento (por exemplo, por perdas de pacotes ou atrasos crescentes), ele reduz sua taxa de envio. O objetivo √© compartilhar a largura de banda da rede de forma "justa" entre as conex√µes TCP.
                    </p>
                </li>
                <li>
                    <h4>Servi√ßo Full-Duplex:</h4>
                    <p>
                        Dados podem fluir em ambas as dire√ß√µes simultaneamente atrav√©s da mesma conex√£o TCP.
                    </p>
                </li>
                <li>
                    <h4>Orientado a Stream de Bytes:</h4>
                    <p>
                        TCP n√£o v√™ os dados como segmentos individuais, mas como um fluxo cont√≠nuo de bytes. Isso significa que o TCP pode juntar pequenos blocos de dados da aplica√ß√£o em um segmento maior para transmiss√£o, ou dividir grandes blocos em m√∫ltiplos segmentos.
                    </p>
                </li>
                <li>
                    <h4>Formato do Segmento TCP:</h4>
                    <p>
                        Um segmento TCP possui um cabe√ßalho mais complexo (20 bytes fixos, mais op√ß√µes), seguido pelos dados da aplica√ß√£o.
                        <pre>
+----------------+----------------+
| Porta de Origem| Porta de Destino|
+----------------+----------------+
|           N√∫mero de Sequ√™ncia     |
+---------------------------------+
|           N√∫mero de Confirma√ß√£o   |
+---------------------------------+
|Desloc. | Res.  | UAPRSF| Janela de |
|Dados   |       | C KSTN| Recep√ß√£o  |
+----------------+----------------+
| Checksum       | Ponteiro Urgente|
+----------------+----------------+
|             Op√ß√µes (vari√°vel)     |
+---------------------------------+
|         Dados da Aplica√ß√£o       |
|                                 |
+---------------------------------+
                        </pre>
                        <ul>
                            <li><strong>Porta de Origem/Destino:</strong> Identificam os processos de aplica√ß√£o.</li>
                            <li><strong>N√∫mero de Sequ√™ncia:</strong> N√∫mero do primeiro byte de dados no segmento.</li>
                            <li><strong>N√∫mero de Confirma√ß√£o (ACK):</strong> O pr√≥ximo n√∫mero de sequ√™ncia esperado pelo receptor do remetente.</li>
                            <li><strong>Comprimento do Cabe√ßalho (Deslocamento de Dados):</strong> Indica onde os dados da aplica√ß√£o come√ßam no segmento TCP.</li>
                            <li><strong>Flags (UAPRSF):</strong> Diversos bits de controle (ex: SYN para estabelecimento de conex√£o, ACK para confirma√ß√£o, FIN para encerramento).</li>
                            <li><strong>Janela de Recep√ß√£o:</strong> Usado para controle de fluxo, indicando o espa√ßo de buffer livre no receptor.</li>
                            <li><strong>Checksum:</strong> Para detec√ß√£o de erros.</li>
                            <li><strong>Ponteiro Urgente:</strong> Usado para indicar dados urgentes.</li>
                            <li><strong>Op√ß√µes:</strong> Campos opcionais (ex: MSS - Maximum Segment Size, para negociar o tamanho m√°ximo do segmento).</li>
                        </ul>
                    </p>
                </li>
            </ul>
        </section>

        <section id="estabelecimento-e-encerramento-de-conexao-tcp" class="chapter-section">
            <h3>Estabelecimento e Encerramento de Conex√£o TCP</h3>
            <p>
                O TCP utiliza o famoso "apresenta√ß√£o de tr√™s vias" para estabelecer uma conex√£o, garantindo que ambos os lados estejam prontos para enviar e receber dados.
            </p>
            <ol>
                <li>
                    <strong>Passo 1 (SYN):</strong> O cliente envia um segmento TCP especial com a flag SYN ligada (e um n√∫mero de sequ√™ncia inicial aleat√≥rio `client_isn`) para o servidor na porta de destino desejada.
                </li>
                <li>
                    <strong>Passo 2 (SYNACK):</strong> O servidor recebe o SYN do cliente, aloca recursos para a conex√£o, e responde com um segmento SYNACK: a flag SYN est√° ligada, a flag ACK est√° ligada, o campo de confirma√ß√£o (`client_isn + 1`) confirma o SYN do cliente, e o servidor inclui seu pr√≥prio n√∫mero de sequ√™ncia inicial aleat√≥rio (`server_isn`).
                </li>
                <li>
                    <strong>Passo 3 (ACK):</strong> O cliente recebe o SYNACK do servidor, aloca recursos, e responde com um segmento ACK: a flag ACK est√° ligada, e o campo de confirma√ß√£o (`server_isn + 1`) confirma o SYNACK do servidor. O primeiro segmento de dados do cliente pode ser inclu√≠do neste ACK.
                </li>
            </ol>
            <p>
                Para encerrar uma conex√£o, o TCP tamb√©m usa uma sequ√™ncia de "apresenta√ß√£o de duas vias" (four-way handshake, na verdade, duas vias em cada sentido):
            </p>
            <ol>
                <li>O lado que quer fechar a conex√£o envia um segmento TCP com a flag FIN ligada.</li>
                <li>O outro lado recebe o FIN, envia um ACK em resposta, e depois de um tempo (quando tiver terminado de enviar seus pr√≥prios dados pendentes) tamb√©m envia um FIN.</li>
                <li>O primeiro lado recebe o segundo FIN, envia um ACK final, e a conex√£o √© completamente fechada.</li>
            </ol>
        </section>

        <section id="resumo-capitulo" class="chapter-section">
            <h3>Resumo do Cap√≠tulo</h3>
            <p>
                Neste cap√≠tulo, mergulhamos na <strong>Camada de Transporte</strong>, o cora√ß√£o da comunica√ß√£o "de processo para processo" na Internet. Entendemos a import√¢ncia da multiplexa√ß√£o e demultiplexa√ß√£o para entregar dados aos aplicativos corretos e exploramos os conceitos de transfer√™ncia confi√°vel de dados.
            </p>
            <p>
                Detalhes foram dados sobre o <strong>UDP</strong>, o protocolo simples e r√°pido, ideal para aplica√ß√µes que priorizam a velocidade sobre a confiabilidade. Em contraste, desvendamos o <strong>TCP</strong>, com seus servi√ßos robustos de confiabilidade, controle de fluxo e controle de congestionamento, essenciais para a maioria das aplica√ß√µes que exigem garantia de entrega. Vimos o formato dos segmentos de cada um e o processo de estabelecimento e encerramento de conex√µes TCP.
            </p>
            <p>
                Compreender a camada de transporte √© fundamental, pois ela serve de ponte entre o mundo das aplica√ß√µes e a rede em si, garantindo que suas informa√ß√µes cheguem ao destino de forma eficaz. No pr√≥ximo cap√≠tulo, desceremos ainda mais na pilha de protocolos para explorar a Camada de Rede, onde o roteamento e o endere√ßamento IP s√£o os protagonistas.
            </p>
        </section>

        <section id="atividades" class="chapter-section">
            <h3>Atividades de Aprendizagem</h3>
            <p>Teste seus conhecimentos sobre o Cap√≠tulo 3 com as seguintes perguntas de m√∫ltipla escolha:</p>

            <!-- Quest√£o 1 -->
            <div class="question-block">
                <p>1. Qual √© a principal fun√ß√£o da multiplexa√ß√£o na camada de transporte do hospedeiro remetente?</p>
                <label>
                    <input type="radio" name="q1_ch3" value="a"> A) Direcionar pacotes entre diferentes redes IP.
                </label>
                <label>
                    <input type="radio" name="q1_ch3" value="b"> B) Entregar dados recebidos ao processo de aplica√ß√£o correto no hospedeiro.
                </label>
                <label>
                    <input type="radio" name="q1_ch3" value="c"> C) Coletar mensagens de diferentes processos de aplica√ß√£o e adicionar cabe√ßalhos para passar √† camada de rede.
                </label>
                <label>
                    <input type="radio" name="q1_ch3" value="d"> D) Garantir que os dados cheguem ao destino na ordem correta e sem perdas.
                </label>
                <button class="check-button" onclick="checkAnswer('q1_ch3', 'c', 'feedback1_ch3')">Verificar Resposta</button>
                <div class="feedback" id="feedback1_ch3"></div>
            </div>

            <!-- Quest√£o 2 -->
            <div class="question-block">
                <p>2. Qual das seguintes caracter√≠sticas N√ÉO √© um servi√ßo provido pelo UDP?</p>
                <label>
                    <input type="radio" name="q2_ch3" value="a"> A) N√£o orientado √† conex√£o.
                </label>
                <label>
                    <input type="radio" name="q2_ch3" value="b"> B) Transfer√™ncia de dados n√£o confi√°vel.
                </label>
                <label>
                    <input type="radio" name="q2_ch3" value="c"> C) Controle de congestionamento.
                </label>
                <label>
                    <input type="radio" name="q2_ch3" value="d"> D) Menor sobrecarga de cabe√ßalho.
                </label>
                <button class="check-button" onclick="checkAnswer('q2_ch3', 'c', 'feedback2_ch3')">Verificar Resposta</button>
                <div class="feedback" id="feedback2_ch3"></div>
            </div>

            <!-- Quest√£o 3 -->
            <div class="question-block">
                <p>3. Qual √© o prop√≥sito da "apresenta√ß√£o de tr√™s vias" (three-way handshake) no TCP?</p>
                <label>
                    <input type="radio" name="q3_ch3" value="a"> A) Transmitir dados de forma n√£o confi√°vel e r√°pida.
                </label>
                <label>
                    <input type="radio" name="q3_ch3" value="b"> B) Encerrar uma conex√£o TCP ap√≥s a transfer√™ncia de dados.
                </label>
                <label>
                    <input type="radio" name="q3_ch3" value="c"> C) Estabelecer uma conex√£o confi√°vel entre cliente e servidor antes da troca de dados.
                </label>
                <label>
                    <input type="radio" name="q3_ch3" value="d"> D) Segmentar mensagens de aplica√ß√£o em pacotes menores.
                </label>
                <button class="check-button" onclick="checkAnswer('q3_ch3', 'c', 'feedback3_ch3')">Verificar Resposta</button>
                <div class="feedback" id="feedback3_ch3"></div>
            </div>

            <!-- Quest√£o 4 -->
            <div class="question-block">
                <p>4. No contexto da transfer√™ncia confi√°vel de dados, o que o receptor TCP envia para indicar que recebeu segmentos sem erro?</p>
                <label>
                    <input type="radio" name="q4_ch3" value="a"> A) NAKs (Negative Acknowledgements)
                </label>
                <label>
                    <input type="radio" name="q4_ch3" value="b"> B) Timers
                </label>
                <label>
                    <input type="radio" name="q4_ch3" value="c"> C) Sequence Numbers
                </label>
                <label>
                    <input type="radio" name="q4_ch3" value="d"> D) ACKs (Acknowledgements)
                </label>
                <button class="check-button" onclick="checkAnswer('q4_ch3', 'd', 'feedback4_ch3')">Verificar Resposta</button>
                <div class="feedback" id="feedback4_ch3"></div>
            </div>

            <!-- Quest√£o 5 -->
            <div class="question-block">
                <p>5. O que o TCP faz para impedir que um remetente r√°pido sobrecarregue um receptor lento?</p>
                <label>
                    <input type="radio" name="q5_ch3" value="a"> A) Aplica controle de congestionamento.
                </label>
                <label>
                    <input type="radio" name="q5_ch3" value="b"> B) Utiliza o servi√ßo n√£o confi√°vel do UDP.
                </label>
                <label>
                    <input type="radio" name="q5_ch3" value="c"> C) Implementa controle de fluxo, informando o tamanho do buffer livre do receptor.
                </label>
                <label>
                    <input type="radio" name="q5_ch3" value="d"> D) Descarta pacotes se o buffer do remetente estiver cheio.
                </label>
                <button class="check-button" onclick="checkAnswer('q5_ch3', 'c', 'feedback5_ch3')">Verificar Resposta</button>
                <div class="feedback" id="feedback5_ch3"></div>
            </div>
        </section>

        <div class="chapter-navigation-buttons">
            <a href="capitulo2.html" class="back-button">‚Üê Cap√≠tulo Anterior</a>
            <a href="capitulo4.html" class="back-button">Pr√≥ximo Cap√≠tulo ‚Üí</a>
        </div>
    </main>

    <!-- Rodap√© do Site -->
    <footer id="contato">
        <div class="container">
            <p>&copy; 2025 Desvendando as Redes. Todos os direitos reservados.</p>
            <div class="social-links">
                <a href="#">Facebook</a>
                <a href="#">Twitter</a>
                <a href="#">LinkedIn</a>
            </div>
        </div>
    </footer>

    <!-- Script para verificar as respostas -->
    <script>
        function checkAnswer(questionName, correctAnswer, feedbackId) {
            const selectedOption = document.querySelector(`input[name="${questionName}"]:checked`);
            const feedbackElement = document.getElementById(feedbackId);

            if (selectedOption) {
                if (selectedOption.value === correctAnswer) {
                    feedbackElement.textContent = "Correto! üéâ";
                    feedbackElement.className = "feedback correct";
                } else {
                    feedbackElement.textContent = "Incorreto. Tente novamente!";
                    feedbackElement.className = "feedback incorrect";
                }
            } else {
                feedbackElement.textContent = "Por favor, selecione uma op√ß√£o.";
                feedbackElement.className = "feedback incorrect";
            }
        }
    </script>
    <!-- Vincula o arquivo JavaScript externo (mesmo que vazio, mant√©m a estrutura) -->
    <script src="script.js"></script>
</body>
</html>
