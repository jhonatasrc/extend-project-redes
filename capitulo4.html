<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cap√≠tulo 4: Camada de Rede</title>
  
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="capitulos.css">
    
</head>
<body>
   
    <header>
        <div class="container">
            <h1>Desvendando as Redes</h1>
            <nav>
                <ul>
                    <li><a href="index.html#inicio">In√≠cio</a></li>
                    <li><a href="index.html#jornada">Nossa Jornada</a></li>
                    <li><a href="index.html#contato">Contato</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main class="container">
        
        <div class="chapter-navigation-buttons">
            <a href="index.html" class="back-button">‚Üê In√≠cio</a>
            <a href="capitulo3.html" class="back-button">‚Üê Cap√≠tulo Anterior</a>
            <a href="capitulo5.html" class="back-button">Pr√≥ximo Cap√≠tulo ‚Üí</a>
        </div>

        <!-- Se√ß√£o de Progresso dos Cap√≠tulos -->
        <section class="chapter-progress">
            <h3>Progresso da Jornada</h3>
            <div class="progress-indicator">
                <a href="capitulo1.html" class="chapter-dot completed" data-chapter="1">1</a>
                <a href="capitulo2.html" class="chapter-dot completed" data-chapter="2">2</a>
                <a href="capitulo3.html" class="chapter-dot completed" data-chapter="3">3</a>
                <a href="capitulo4.html" class="chapter-dot completed current-chapter" data-chapter="4">4</a>
                <a href="capitulo5.html" class="chapter-dot" data-chapter="5">5</a>
                <a href="capitulo6.html" class="chapter-dot" data-chapter="6">6</a>
                <a href="capitulo7.html" class="chapter-dot" data-chapter="7">7</a>
                <a href="capitulo8.html" class="chapter-dot" data-chapter="8">8</a>
                <a href="capitulo9.html" class="chapter-dot" data-chapter="9">9</a>
            </div>
            <p>Cap√≠tulos conclu√≠dos: <span id="completed-count">4</span> de <span id="total-chapters">9</span></p>
        </section>

        <section id="capitulo-intro" class="chapter-section">
            <h2>Camada de Rede</h2>
            <p>
                Ap√≥s explorar as camadas de aplica√ß√£o e transporte, que focam na comunica√ß√£o entre processos, vamos agora mergulhar na <strong>Camada de Rede</strong>. Esta camada √© o "cora√ß√£o" da Internet, respons√°vel por levar pacotes de dados de um hospedeiro (computador ou dispositivo conectado) para outro, atrav√©s de uma vasta rede de roteadores. Pense na camada de rede como o sistema postal global que garante que sua carta (pacote) chegue √† cidade e ao pr√©dio correto, independentemente de onde a carta foi enviada e de quantas ag√™ncias postais (roteadores) ela precise passar.
            </p>
            <p>
                A principal fun√ß√£o da camada de rede √© o <strong>encaminhamento fim a fim</strong> de pacotes (datagramas) entre sistemas finais. Para realizar isso, ela deve lidar com duas tarefas cruciais: <strong>repasse</strong> e <strong>roteamento</strong>.
            </p>
            <ul>
                <li>
                    <strong>Repasse (Forwarding):</strong> √â a a√ß√£o local de um roteador de mover um pacote de sua interface de entrada para a interface de sa√≠da apropriada. √â como um funcion√°rio dos correios decidindo para qual esteira um pacote deve ir dentro de uma ag√™ncia.
                </li>
                <li>
                    <strong>Roteamento (Routing):</strong> √â o processo de determinar a rota completa que os pacotes percorrer√£o da origem ao destino. Isso envolve a cria√ß√£o de tabelas de repasse nos roteadores e √© feito por algoritmos de roteamento. √â como planejar a rota de uma carta desde o remetente at√© o destinat√°rio final, passando por todas as ag√™ncias necess√°rias.
                </li>
            </ul>
            <p>
                Neste cap√≠tulo, exploraremos os modelos de servi√ßo da camada de rede, os princ√≠pios dos roteadores, o essencial Protocolo IP e os complexos algoritmos e protocolos de roteamento que fazem a Internet funcionar.
            </p>
        </section>

        <section id="visao-geral-camada-rede" class="chapter-section">
            <h3>Vis√£o Geral da Camada de Rede</h3>
            <p>
                A camada de rede reside em cada hospedeiro e em cada roteador da rede. No remetente, a camada de transporte passa um segmento √† camada de rede, que o encapsula em um <strong>datagrama</strong> e o encaminha para o destino. No receptor, a camada de rede entrega o segmento ao protocolo de transporte adequado.
            </p>

            <h4>Modelos de Servi√ßo da Camada de Rede</h4>
            <p>
                Uma rede pode oferecer diferentes modelos de servi√ßo para a camada de transporte. Os dois modelos principais s√£o:
            </p>
            <ul>
                <li>
                    <h5>Servi√ßo de Datagrama (Best-Effort Service):</h5>
                    <p>
                        Este √© o modelo de servi√ßo da Internet. Ele garante que os datagramas sejam entregues entre a origem e o destino, mas sem qualquer garantia de ordem, aus√™ncia de perda, atraso m√≠nimo ou garantia de largura de banda. Cada datagrama √© tratado de forma independente, e a rede tenta entreg√°-lo, mas n√£o promete nada. A camada de transporte (TCP) √© respons√°vel pela confiabilidade, se necess√°ria.
                    </p>
                </li>
                <li>
                    <h5>Servi√ßo de Circuito Virtual (Virtual-Circuit Service - VC):</h5>
                    <p>
                        Neste modelo, uma conex√£o (circuito virtual) √© estabelecida entre os dois sistemas finais antes da transfer√™ncia de dados. Durante o estabelecimento, os roteadores intermedi√°rios reservam recursos para a conex√£o, garantindo uma qualidade de servi√ßo (QoS) para o tr√°fego. Todos os pacotes da mesma conex√£o VC seguem o mesmo caminho e chegam na ordem correta. As redes de telefonia s√£o um exemplo cl√°ssico de comuta√ß√£o de circuitos, que t√™m semelhan√ßas com o servi√ßo de circuito virtual.
                    </p>
                </li>
            </ul>
            <p>
                A Internet usa o servi√ßo de datagrama (sem conex√£o na camada de rede), enquanto outras redes (como X.25, ATM) usaram ou usam circuitos virtuais. A Internet preferiu o servi√ßo de datagrama por sua simplicidade e robustez: roteadores n√£o precisam manter "estado" de conex√£o para cada fluxo de dados, tornando-os mais escal√°veis e resilientes a falhas.
            </p>
        </section>

        <section id="roteadores" class="chapter-section">
            <h3>Roteadores: Os Guardi√µes do Tr√°fego</h3>
            <p>
                Um roteador √© o dispositivo chave na camada de rede, respons√°vel pelo repasse de pacotes entre diferentes redes. Ele possui duas fun√ß√µes principais:
            </p>
            <ul>
                <li>
                    <strong>Plano de Controle:</strong> √â o "c√©rebro" do roteador. Ele executa os algoritmos e protocolos de roteamento (como RIP, OSPF, BGP) que calculam as melhores rotas e preenchem as tabelas de repasse.
                </li>
                <li>
                    <strong>Plano de Dados (Plano de Repasse):</strong> √â o "corpo" do roteador, que realiza o trabalho de repasse de pacotes. Ele √© implementado em hardware de alta velocidade e executa a fun√ß√£o de repasse.
                </li>
            </ul>

            <h4>Arquitetura de um Roteador</h4>
            <p>
                Um roteador moderno √© composto por:
            </p>
            <ul>
                <li>
                    <h5>Portas de Entrada:</h5>
                    <p>
                        Aqui chegam os pacotes dos enlaces de entrada. A porta de entrada realiza:
                        <ul>
                            <li><strong>Fun√ß√£o da Camada F√≠sica:</strong> Termina√ß√£o f√≠sica do enlace de entrada.</li>
                            <li><strong>Fun√ß√£o da Camada de Enlace:</strong> Processamento do protocolo de enlace de dados (ex: Ethernet).</li>
                            <li><strong>Fun√ß√£o de Consulta de Repasse:</strong> A mais importante. A porta de entrada pesquisa a tabela de repasse para determinar a porta de sa√≠da. Isso deve ser feito muito rapidamente para n√£o atrasar o pacote.</li>
                            <li><strong>Fila de Entrada:</strong> Buffer onde os pacotes esperam se a comuta√ß√£o (transi√ß√£o para a porta de sa√≠da) n√£o for r√°pida o suficiente. Pode ocorrer perda de pacote (head-of-line blocking).</li>
                        </ul>
                    </p>
                </li>
                <li>
                    <h5>Malha de Comuta√ß√£o (Switching Fabric):</h5>
                    <p>
                        √â o componente central do roteador que conecta as portas de entrada √†s portas de sa√≠da. √â a "autoestrada interna" que move pacotes de um buffer de entrada para um buffer de sa√≠da. Existem tr√™s tipos principais de comuta√ß√£o:
                        <ul>
                            <li><strong>Via Mem√≥ria:</strong> Roteadores mais antigos, onde a CPU move pacotes entre buffers na mem√≥ria. Lento.</li>
                            <li><strong>Via Barramento:</strong> Todas as portas compartilham um barramento comum. Mais r√°pido que a mem√≥ria, mas o barramento pode ser um gargalo.</li>
                            <li><strong>Via Interconex√£o (Crossbar):</strong> Matriz de interconex√£o que permite que m√∫ltiplas portas transfiram pacotes em paralelo, com alta capacidade. Mais complexo e caro.</li>
                        </ul>
                    </p>
                </li>
                <li>
                    <h5>Portas de Sa√≠da:</h5>
                    <p>
                        Aqui os pacotes s√£o enviados para os enlaces de sa√≠da. A porta de sa√≠da armazena os pacotes que chegam da malha de comuta√ß√£o em um buffer de fila.
                        <ul>
                            <li><strong>Fila de Sa√≠da:</strong> Buffer onde os pacotes esperam sua vez para serem transmitidos pelo enlace de sa√≠da. Se o enlace de sa√≠da estiver congestionado, esta fila pode transbordar, causando perda de pacotes. O gerenciamento de filas (descartar pacotes, agendamento de pacotes) √© importante aqui.</li>
                            <li><strong>Fun√ß√£o da Camada de Enlace:</strong> Processamento do protocolo de enlace de dados.</li>
                            <li><strong>Fun√ß√£o da Camada F√≠sica:</strong> Transmiss√£o de bits para o enlace de sa√≠da.</li>
                        </ul>
                    </p>
                </li>
                <li>
                    <h5>Processador de Roteamento:</h5>
                    <p>
                        Executa os protocolos e algoritmos de roteamento, mant√©m as tabelas de repasse e gerencia os componentes do roteador. Opera no plano de controle.
                    </p>
                </li>
            </ul>
        </section>

        <section id="protocolo-ip" class="chapter-section">
            <h3>Protocolo IP: O Endere√ßo da Internet</h3>
            <p>
                O <strong>Internet Protocol (IP)</strong> √© o protocolo de camada de rede central da Internet. Ele define o formato dos datagramas e como os roteadores devem repass√°-los.
            </p>

            <h4>O Datagrama IPv4</h4>
            <p>
                Um datagrama IPv4 √© a unidade fundamental de dados que viaja na camada de rede. Ele tem um cabe√ßalho fixo de 20 bytes (sem op√ß√µes), mais o tamanho vari√°vel das op√ß√µes e os dados (payload) que v√™m da camada de transporte.
                <pre>
+------------------------------------+
| Vers√£o | HLEN | Tipo de Servi√ßo | Comprimento Total    |
+------------------------------------+
| Identifica√ß√£o     | Flags | Deslocamento do Fragmento |
+------------------------------------+
| Tempo de Vida (TTL)| Protocolo | Checksum do Cabe√ßalho |
+------------------------------------+
|                Endere√ßo IP de Origem                |
+------------------------------------+
|               Endere√ßo IP de Destino                |
+------------------------------------+
|              Op√ß√µes (vari√°vel)                     |
+------------------------------------+
|             Dados (Payload)                        |
|                                    |
+------------------------------------+
                </pre>
                <ul>
                    <li><strong>Vers√£o:</strong> 4 (para IPv4).</li>
                    <li><strong>HLEN (Header Length):</strong> Comprimento do cabe√ßalho em m√∫ltiplos de 4 bytes.</li>
                    <li><strong>Tipo de Servi√ßo (Type of Service - QoS):</strong> Obsoleto, mas historicamente usado para indicar prioridade ou tipo de servi√ßo desejado.</li>
                    <li><strong>Comprimento Total:</strong> Tamanho total do datagrama em bytes (cabe√ßalho + dados).</li>
                    <li><strong>Identifica√ß√£o, Flags, Deslocamento do Fragmento:</strong> Usados para fragmenta√ß√£o/remontagem de datagramas, caso ele seja maior que o MTU (Maximum Transmission Unit) de um enlace.</li>
                    <li><strong>Tempo de Vida (TTL - Time-To-Live):</strong> Um contador que √© decrementado a cada roteador. Se chegar a zero, o datagrama √© descartado, evitando loops infinitos na rede.</li>
                    <li><strong>Protocolo:</strong> Indica o protocolo da camada de transporte para o qual o payload deve ser entregue (ex: 6 para TCP, 17 para UDP).</li>
                    <li><strong>Checksum do Cabe√ßalho:</strong> Para detectar erros apenas no cabe√ßalho.</li>
                    <li><strong>Endere√ßo IP de Origem/Destino:</strong> Os endere√ßos IP de 32 bits dos hospedeiros remetente e destinat√°rio.</li>
                    <li><strong>Op√ß√µes:</strong> Campos opcionais para fun√ß√µes especiais (ex: grava√ß√£o de rota, carimbo de tempo). Raramente usados.</li>
                </ul>
            </p>

            <h4>Endere√ßamento IPv4</h4>
            <p>
                Um <strong>endere√ßo IP</strong> √© um identificador √∫nico de 32 bits para uma interface em um hospedeiro ou roteador. Uma interface √© o ponto de conex√£o f√≠sica de um dispositivo com um enlace.
            </p>
            <ul>
                <li>
                    <h5>Sub-redes (Subnets):</h5>
                    <p>
                        Uma <strong>sub-rede</strong> √© um grupo de interfaces de hospedeiros e roteadores que t√™m a mesma por√ß√£o de prefixo em seu endere√ßo IP e podem se alcan√ßar sem passar por um roteador. Elas formam redes IP independentes. O endere√ßo IP consiste em duas partes: um <strong>ID de sub-rede</strong> (prefixo) e um <strong>ID de hospedeiro</strong>.
                    </p>
                </li>
                <li>
                    <h5>Classless Inter-Domain Routing (CIDR - Roteamento Entre Dom√≠nios Sem Classe):</h5>
                    <p>
                        Substituiu o endere√ßamento IP baseado em classes (A, B, C). O CIDR usa a nota√ß√£o <code>a.b.c.d/x</code>, onde <code>x</code> √© o n√∫mero de bits do prefixo da rede (ou ID de sub-rede). Isso permite maior flexibilidade na aloca√ß√£o de endere√ßos IP, pois os blocos podem ter tamanhos mais variados.
                    </p>
                </li>
                <li>
                    <h5>Obten√ß√£o de Endere√ßos IP (DHCP):</h5>
                    <p>
                        O <strong>DHCP (Dynamic Host Configuration Protocol)</strong> permite que hospedeiros obtenham endere√ßos IP automaticamente quando se conectam a uma rede.
                        <ul>
                            <li><strong>Descoberta DHCP:</strong> Cliente envia uma mensagem "DHCP discover" (broadcast).</li>
                            <li><strong>Oferta DHCP:</strong> Servidor DHCP responde com uma "DHCP offer" (endere√ßo IP, m√°scara de sub-rede, gateway padr√£o, tempo de vida da concess√£o).</li>
                            <li><strong>Requisi√ß√£o DHCP:</strong> Cliente solicita o endere√ßo IP oferecido.</li>
                            <li><strong>ACK DHCP:</strong> Servidor confirma a concess√£o do endere√ßo IP.</li>
                        </ul>
                    </p>
                </li>
                <li>
                    <h5>Network Address Translation (NAT - Tradu√ß√£o de Endere√ßos de Rede):</h5>
                    <p>
                        Para economizar endere√ßos IPv4 p√∫blicos (que est√£o se esgotando), muitas redes locais usam endere√ßos IP privados (n√£o rote√°veis na Internet p√∫blica) e um dispositivo NAT (geralmente o roteador dom√©stico) para traduzi-los para um √∫nico endere√ßo IP p√∫blico ao se comunicar com a Internet externa. O dispositivo NAT mant√©m uma tabela de tradu√ß√£o para mapear requisi√ß√µes e respostas de volta aos hospedeiros internos.
                    </p>
                </li>
                <li>
                    <h5>IPv6:</h5>
                    <p>
                        A pr√≥xima gera√ß√£o do Protocolo IP, com endere√ßos de 128 bits, resolve o problema de escassez de endere√ßos IPv4. Al√©m de mais endere√ßos, o IPv6 simplifica o cabe√ßalho do datagrama e oferece outras melhorias. A transi√ß√£o do IPv4 para o IPv6 est√° em andamento, mas √© lenta devido √† vasta infraestrutura IPv4 existente. T√©cnicas como <strong>tunelamento</strong> s√£o usadas para encapsular datagramas IPv6 em datagramas IPv4 para travessia de redes IPv4.
                    </p>
                </li>
            </ul>
        </section>

        <section id="icmp" class="chapter-section">
            <h3>ICMP (Internet Control Message Protocol)</h3>
            <p>
                O <strong>ICMP (Internet Control Message Protocol)</strong> √© um protocolo de camada de rede usado pelos hospedeiros e roteadores para comunicar informa√ß√µes de controle ou mensagens de erro. √â como o "sistema de feedback" da camada de rede.
            </p>
            <ul>
                <li>O ICMP √© transportado dentro de datagramas IP.</li>
                <li>Mensagens ICMP incluem tipo e c√≥digo, al√©m de informa√ß√µes sobre o erro (ex: parte do datagrama IP que causou o erro).</li>
                <li>Exemplos de uso:
                    <ul>
                        <li><strong>Echo Request/Reply (Ping):</strong> Usado para verificar a conectividade entre dois hospedeiros.</li>
                        <li><strong>Destination Unreachable:</strong> Informa que um datagrama n√£o p√¥de ser entregue a um destino.</li>
                        <li><strong>Time Exceeded:</strong> Enviado quando o TTL de um datagrama chega a zero (usado pelo Traceroute).</li>
                    </ul>
                </li>
            </ul>
        </section>

        <section id="algoritmos-de-roteamento" class="chapter-section">
            <h3>Algoritmos de Roteamento</h3>
            <p>
                Os algoritmos de roteamento s√£o a "intelig√™ncia" do plano de controle, determinando o caminho que os pacotes devem seguir da origem ao destino. Eles preenchem as tabelas de repasse nos roteadores.
            </p>
            <ul>
                <li>
                    <h4>Algoritmos de Roteamento Global (Link-State - LS):</h4>
                    <p>
                        Todos os roteadores t√™m informa√ß√µes completas sobre a topologia da rede e os custos de cada enlace. Cada roteador calcula o caminho de menor custo para todos os destinos.
                    </p>
                    <ul>
                        <li>
                            <strong>Algoritmo de Dijkstra:</strong> √â o algoritmo mais comum para roteamento de estado de enlace.
                            <ol>
                                <li>Cada n√≥ (roteador) difunde o "estado de seus enlaces" (seus custos para seus vizinhos diretos) para todos os outros n√≥s na rede.</li>
                                <li>Cada n√≥ ent√£o constr√≥i um mapa completo da rede (gr√°fico).</li>
                                <li>Com base nesse mapa, cada n√≥ usa o algoritmo de Dijkstra para calcular o caminho de menor custo de si mesmo para todos os outros n√≥s.</li>
                            </ol>
                        </li>
                        <li><strong>Vantagens:</strong> Converg√™ncia r√°pida, sem loops de roteamento.</li>
                        <li><strong>Desvantagens:</strong> Mais complexo (exige mais recursos computacionais), vulner√°vel a erros de difus√£o de estado.</li>
                    </ul>
                </li>
                <li>
                    <h4>Algoritmos de Roteamento Descentralizado (Distance-Vector - DV):</h4>
                    <p>
                        Cada roteador s√≥ conhece os custos dos enlaces para seus vizinhos diretos. Ele troca informa√ß√µes com seus vizinhos sobre as dist√¢ncias estimadas para todos os destinos e atualiza suas pr√≥prias estimativas. O processo √© iterativo.
                    </p>
                    <ul>
                        <li>
                            <strong>Equa√ß√£o de Bellman-Ford:</strong> A base do algoritmo de vetor de dist√¢ncia. A dist√¢ncia de um n√≥ `x` para um destino `y` atrav√©s de um vizinho `v` √© o custo do enlace `x` a `v` somado √† dist√¢ncia de `v` a `y`. O n√≥ `x` escolhe o vizinho `v` que minimiza essa soma.
                        </li>
                        <li><strong>Vantagens:</strong> Menos complexo de implementar, menor sobrecarga de mensagens.</li>
                        <li><strong>Desvantagens:</strong> Converg√™ncia mais lenta ("contagem at√© o infinito" se houver falhas), pode gerar loops de roteamento tempor√°rios.</li>
                    </ul>
                </li>
            </ul>
        </section>

        <section id="roteamento-na-internet" class="chapter-section">
            <h3>Roteamento na Internet</h3>
            <p>
                A Internet √© grande demais para um √∫nico algoritmo de roteamento. Ela √© organizada em **Sistemas Aut√¥nomos (AS - Autonomous Systems)**. Um AS √© um grupo de roteadores sob a mesma administra√ß√£o.
            </p>
            <ul>
                <li>
                    <h4>Roteamento Intra-AS (Interior Gateway Protocols - IGPs):</h4>
                    <p>
                        Algoritmos que roteiam pacotes dentro de um mesmo Sistema Aut√¥nomo.
                        <ul>
                            <li><strong>RIP (Routing Information Protocol):</strong> Algoritmo de vetor de dist√¢ncia mais antigo, usa "contagem de saltos" como m√©trica. M√°ximo de 15 saltos. Simples, mas limitado.</li>
                            <li><strong>OSPF (Open Shortest Path First):</strong> Algoritmo de estado de enlace (Dijkstra), mais moderno e amplamente usado. Permite hierarquia dentro do AS (√°reas) para escalabilidade. Usa custos de enlace.</li>
                        </ul>
                    </p>
                </li>
                <li>
                    <h4>Roteamento Inter-AS (Exterior Gateway Protocols - EGPs):</h4>
                    <p>
                        Algoritmos que roteiam pacotes entre diferentes Sistemas Aut√¥nomos.
                        <ul>
                            <li>
                                <strong>BGP (Border Gateway Protocol):</strong> O protocolo de roteamento inter-AS padr√£o da Internet.
                                <ul>
                                    <li>Pares BGP (roteadores na borda de ASs) trocam informa√ß√µes de alcan√ßabilidade de prefixos (blocos de endere√ßos IP) e os caminhos de ASs para alcan√ßar esses prefixos.</li>
                                    <li>Permite que cada AS defina suas pr√≥prias pol√≠ticas de roteamento (ex: n√£o rotear tr√°fego por um AS concorrente, priorizar rotas mais baratas).</li>
                                    <li>Baseado em "pol√≠ticas", n√£o apenas em custos de caminho.</li>
                                </ul>
                            </li>
                        </ul>
                    </p>
                </li>
            </ul>
        </section>

        <section id="resumo-capitulo" class="chapter-section">
            <h3>Resumo do Cap√≠tulo</h3>
            <p>
                Neste cap√≠tulo, fizemos uma profunda imers√£o na <strong>Camada de Rede</strong>, entendendo seu papel fundamental no encaminhamento de pacotes de um hospedeiro a outro. Diferenciamos os modelos de servi√ßo de datagrama (usado na Internet) e circuito virtual, e exploramos a arquitetura interna de um roteador, desde suas portas de entrada/sa√≠da at√© a malha de comuta√ß√£o e o processador de roteamento.
            </p>
            <p>
                Aprofundamos no cora√ß√£o da camada de rede com o <strong>Protocolo IP</strong> (IPv4 e IPv6), analisando o formato dos datagramas e os desafios do endere√ßamento. Discutimos tamb√©m o papel do <strong>ICMP</strong> como protocolo de controle e mensagens de erro.
            </p>
            <p>
                Por fim, desvendamos os complexos <strong>algoritmos de roteamento</strong> (estado de enlace e vetor de dist√¢ncia) e como eles s√£o aplicados na pr√°tica na Internet, com os protocolos <strong>intra-AS</strong> (RIP, OSPF) e o poderoso protocolo <strong>inter-AS</strong>, o BGP.
            </p>
            <p>
                Compreender a camada de rede √© essencial para entender como a Internet funciona em sua escala global, garantindo que bilh√µes de pacotes cheguem aos seus destinos diariamente. No pr√≥ximo cap√≠tulo, subiremos para a camada de enlace, que lida com a comunica√ß√£o entre n√≥s adjacentes.
            </p>
        </section>

        <section id="atividades" class="chapter-section">
            <h3>Atividades de Aprendizagem</h3>
            <p>Teste seus conhecimentos sobre o Cap√≠tulo 4 com as seguintes perguntas de m√∫ltipla escolha:</p>

            <!-- Quest√£o 1 -->
            <div class="question-block">
                <p>1. Qual √© a principal diferen√ßa entre a fun√ß√£o de repasse (forwarding) e a fun√ß√£o de roteamento (routing) na camada de rede?</p>
                <label>
                    <input type="radio" name="q1_ch4" value="a"> A) Repasse determina a rota completa, enquanto roteamento move pacotes de uma interface para outra.
                </label>
                <label>
                    <input type="radio" name="q1_ch4" value="b"> B) Repasse √© uma a√ß√£o local do roteador; roteamento √© um processo global de determina√ß√£o de rotas.
                </label>
                <label>
                    <input type="radio" name="q1_ch4" value="c"> C) Repasse ocorre na camada de transporte, e roteamento na camada de rede.
                </label>
                <label>
                    <input type="radio" name="q1_ch4" value="d"> D) Ambas as fun√ß√µes s√£o id√™nticas e interligadas.
                </label>
                <button class="check-button" onclick="checkAnswer('q1_ch4', 'b', 'feedback1_ch4')">Verificar Resposta</button>
                <div class="feedback" id="feedback1_ch4"></div>
            </div>

            <!-- Quest√£o 2 -->
            <div class="question-block">
                <p>2. Qual componente da arquitetura de um roteador √© respons√°vel por executar os algoritmos e protocolos de roteamento e manter as tabelas de repasse?</p>
                <label>
                    <input type="radio" name="q2_ch4" value="a"> A) Porta de Entrada
                </label>
                <label>
                    <input type="radio" name="q2_ch4" value="b"> B) Malha de Comuta√ß√£o
                </label>
                <label>
                    <input type="radio" name="q2_ch4" value="c"> C) Porta de Sa√≠da
                </label>
                <label>
                    <input type="radio" name="q2_ch4" value="d"> D) Processador de Roteamento
                </label>
                <button class="check-button" onclick="checkAnswer('q2_ch4', 'd', 'feedback2_ch4')">Verificar Resposta</button>
                <div class="feedback" id="feedback2_ch4"></div>
            </div>

            <!-- Quest√£o 3 -->
            <div class="question-block">
                <p>3. No cabe√ßalho de um datagrama IPv4, qual campo √© decrementado a cada roteador e, se chegar a zero, causa o descarte do datagrama?</p>
                <label>
                    <input type="radio" name="q3_ch4" value="a"> A) Comprimento Total
                </label>
                <label>
                    <input type="radio" name="q3_ch4" value="b"> B) Identifica√ß√£o
                </label>
                <label>
                    <input type="radio" name="q3_ch4" value="c"> C) Tempo de Vida (TTL)
                </label>
                <label>
                    <input type="radio" name="q3_ch4" value="d"> D) Checksum do Cabe√ßalho
                </label>
                <button class="check-button" onclick="checkAnswer('q3_ch4', 'c', 'feedback3_ch4')">Verificar Resposta</button>
                <div class="feedback" id="feedback3_ch4"></div>
            </div>

            <!-- Quest√£o 4 -->
            <div class="question-block">
                <p>4. Qual algoritmo de roteamento intra-AS √© um algoritmo de vetor de dist√¢ncia que usa "contagem de saltos" como m√©trica e tem um limite m√°ximo de 15 saltos?</p>
                <label>
                    <input type="radio" name="q4_ch4" value="a"> A) OSPF (Open Shortest Path First)
                </label>
                <label>
                    <input type="radio" name="q4_ch4" value="b"> B) BGP (Border Gateway Protocol)
                </label>
                <label>
                    <input type="radio" name="q4_ch4" value="c"> C) RIP (Routing Information Protocol)
                </label>
                <label>
                    <input type="radio" name="q4_ch4" value="d"> D) Algoritmo de Dijkstra
                </label>
                <button class="check-button" onclick="checkAnswer('q4_ch4', 'c', 'feedback4_ch4')">Verificar Resposta</button>
                <div class="feedback" id="feedback4_ch4"></div>
            </div>

            <!-- Quest√£o 5 -->
            <div class="question-block">
                <p>5. O que o protocolo DHCP permite que os hospedeiros fa√ßam ao se conectar a uma rede?</p>
                <label>
                    <input type="radio" name="q5_ch4" value="a"> A) Traduzir nomes de hospedeiro para endere√ßos IP.
                </label>
                <label>
                    <input type="radio" name="q5_ch4" value="b"> B) Obter endere√ßos IP automaticamente.
                </label>
                <label>
                    <input type="radio" name="q5_ch4" value="c"> C) Fragmentar e remontar datagramas IP.
                </label>
                <label>
                    <input type="radio" name="q5_ch4" value="d"> D) Estabelecer conex√µes confi√°veis entre processos.
                </label>
                <button class="check-button" onclick="checkAnswer('q5_ch4', 'b', 'feedback5_ch4')">Verificar Resposta</button>
                <div class="feedback" id="feedback5_ch4"></div>
            </div>
        </section>

        <div class="chapter-navigation-buttons">
            <a href="capitulo3.html" class="back-button">‚Üê Cap√≠tulo Anterior</a>
            <a href="capitulo5.html" class="back-button">Pr√≥ximo Cap√≠tulo ‚Üí</a>
        </div>
    </main>

    <!-- Rodap√© do Site -->
    <footer id="contato">
        <div class="container">
            <p>&copy; 2025 Desvendando as Redes. Todos os direitos reservados.</p>
            <div class="social-links">
                <a href="#">Facebook</a>
                <a href="#">Twitter</a>
                <a href="#">LinkedIn</a>
            </div>
        </div>
    </footer>

    
    <script>
        function checkAnswer(questionName, correctAnswer, feedbackId) {
            const selectedOption = document.querySelector(`input[name="${questionName}"]:checked`);
            const feedbackElement = document.getElementById(feedbackId);

            if (selectedOption) {
                if (selectedOption.value === correctAnswer) {
                    feedbackElement.textContent = "Correto! üéâ";
                    feedbackElement.className = "feedback correct";
                } else {
                    feedbackElement.textContent = "Incorreto. Tente novamente!";
                    feedbackElement.className = "feedback incorrect";
                }
            } else {
                feedbackElement.textContent = "Por favor, selecione uma op√ß√£o.";
                feedbackElement.className = "feedback incorrect";
            }
        }
    </script>
    <!-- Vincula o arquivo JavaScript externo (mesmo que vazio, mant√©m a estrutura) -->
    <script src="script.js"></script>
</body>
</html>
