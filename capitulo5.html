<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cap√≠tulo 5: Camada de Enlace</title>
   
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
   
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="capitulos.css">
    
</head>
<body>
    
    <header>
        <div class="container">
            <h1>Desvendando as Redes</h1>
            <nav>
                <ul>
                    <li><a href="index.html#inicio">In√≠cio</a></li>
                    <li><a href="index.html#jornada">Nossa Jornada</a></li>
                    <li><a href="index.html#contato">Contato</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main class="container">
        <!-- Bot√µes de navega√ß√£o no topo da p√°gina -->
        <div class="chapter-navigation-buttons">
            <a href="index.html" class="back-button">‚Üê In√≠cio</a>
            <a href="capitulo4.html" class="back-button">‚Üê Cap√≠tulo Anterior</a>
            <a href="capitulo6.html" class="back-button">Pr√≥ximo Cap√≠tulo ‚Üí</a>
        </div>

        <!-- Se√ß√£o de Progresso dos Cap√≠tulos -->
        <section class="chapter-progress">
            <h3>Progresso da Jornada</h3>
            <div class="progress-indicator">
                <a href="capitulo1.html" class="chapter-dot completed" data-chapter="1">1</a>
                <a href="capitulo2.html" class="chapter-dot completed" data-chapter="2">2</a>
                <a href="capitulo3.html" class="chapter-dot completed" data-chapter="3">3</a>
                <a href="capitulo4.html" class="chapter-dot completed" data-chapter="4">4</a>
                <a href="capitulo5.html" class="chapter-dot completed current-chapter" data-chapter="5">5</a>
                <a href="capitulo6.html" class="chapter-dot" data-chapter="6">6</a>
                <a href="capitulo7.html" class="chapter-dot" data-chapter="7">7</a>
                <a href="capitulo8.html" class="chapter-dot" data-chapter="8">8</a>
                <a href="capitulo9.html" class="chapter-dot" data-chapter="9">9</a>
            </div>
            <p>Cap√≠tulos conclu√≠dos: <span id="completed-count">5</span> de <span id="total-chapters">9</span></p>
        </section>

        <section id="capitulo-intro" class="chapter-section">
            <h2>Camada de Enlace</h2>
            <p>
                No cap√≠tulo anterior, aprofundamos na camada de rede, a respons√°vel por rotear pacotes de um hospedeiro a outro atrav√©s de toda a Internet. Agora, vamos descer um n√≠vel na pilha de protocolos e focar na <strong>Camada de Enlace</strong>. Pense na camada de enlace como a respons√°vel pelas "entregas locais" entre dois dispositivos que est√£o diretamente conectados (adjacentes).
            </p>
            <p>
                A camada de enlace tem a tarefa de levar os dados de um n√≥ (pode ser um hospedeiro ou um roteador) para um n√≥ <strong>adjacente</strong> ao longo de um √∫nico enlace de comunica√ß√£o. Embora a camada de rede se preocupe com o caminho fim a fim, a camada de enlace garante que cada "salto" individual (cada trecho da viagem do pacote) seja feito de forma confi√°vel e eficiente.
            </p>
            <p>
                Neste cap√≠tulo, exploraremos os servi√ßos fornecidos pela camada de enlace, as t√©cnicas de detec√ß√£o e corre√ß√£o de erros, como m√∫ltiplos dispositivos compartilham um mesmo meio de comunica√ß√£o (protocolos de acesso m√∫ltiplo), o papel dos endere√ßos MAC, a onipresente Ethernet, o funcionamento dos comutadores (switches) e conceitos mais avan√ßados como VLANs e MPLS.
            </p>
        </section>

        <section id="servicos-camada-enlace" class="chapter-section">
            <h3>Servi√ßos da Camada de Enlace</h3>
            <p>
                A camada de enlace fornece um conjunto de servi√ßos para a camada de rede acima dela. O principal servi√ßo √© a transfer√™ncia de dados de um n√≥ para um n√≥ adjacente.
            </p>
            <ul>
                <li>
                    <h4>Enquadramento (Framing):</h4>
                    <p>
                        A camada de rede entrega um datagrama √† camada de enlace, que o encapsula em um <strong>quadro (frame)</strong>. Um quadro inclui campos de dados (o datagrama) e de cabe√ßalho, al√©m de um campo de trailer. O cabe√ßalho e o trailer do quadro cont√™m informa√ß√µes importantes, como o endere√ßo f√≠sico (MAC) de origem e destino, e bits para detec√ß√£o de erros. O enquadramento √© essencial para que o receptor possa identificar onde um quadro come√ßa e termina.
                    </p>
                </li>
                <li>
                    <h4>Acesso ao Meio (Media Access):</h4>
                    <p>
                        Quando v√°rios n√≥s compartilham um mesmo meio de transmiss√£o (como em uma rede Wi-Fi ou um cabo Ethernet compartilhado), a camada de enlace precisa de regras para controlar quem pode transmitir dados em um dado momento para evitar colis√µes. Os <strong>protocolos de acesso m√∫ltiplo</strong> s√£o respons√°veis por isso.
                    </p>
                </li>
                <li>
                    <h4>Detec√ß√£o e Corre√ß√£o de Erros:</h4>
                    <p>
                        Os bits em um quadro podem ser corrompidos por ru√≠do no enlace. A camada de enlace pode incluir mecanismos para <strong>detectar erros</strong> e, em alguns casos, at√© mesmo <strong>corrigir erros</strong>. Isso √© feito adicionando bits de detec√ß√£o de erro ao quadro, que o receptor verifica. Se um erro for detectado, o quadro pode ser descartado ou uma retransmiss√£o pode ser solicitada.
                    </p>
                </li>
                <li>
                    <h4>Transfer√™ncia Confi√°vel de Dados:</h4>
                    <p>
                        Alguns protocolos de enlace de dados (mas n√£o todos) fornecem um servi√ßo de transfer√™ncia confi√°vel, garantindo que os quadros sejam entregues sem erros e na ordem correta. Isso √© feito atrav√©s de confirma√ß√µes (ACKs) e retransmiss√µes, de forma semelhante ao TCP, mas em um escopo "salto a salto". Redes com alta taxa de erros (como redes sem fio) podem se beneficiar mais dessa confiabilidade no n√≠vel do enlace.
                    </p>
                </li>
                <li>
                    <h4>Controle de Fluxo:</h4>
                    <p>
                        Assim como na camada de transporte, a camada de enlace pode usar controle de fluxo para impedir que um n√≥ remetente sobrecarregue o buffer do n√≥ receptor adjacente.
                    </p>
                </li>
            </ul>
        </section>

        <section id="deteccao-correcao-erros" class="chapter-section">
            <h3>Detec√ß√£o e Corre√ß√£o de Erros</h3>
            <p>
                Bits podem ser "virados" (corrompidos) durante a transmiss√£o. A camada de enlace (e tamb√©m a de transporte) usa t√©cnicas para detectar e, √†s vezes, corrigir esses erros.
            </p>
            <ul>
                <li>
                    <h4>Bits de Paridade:</h4>
                    <p>
                        O m√©todo mais simples. Adiciona um bit extra ao dado para que o n√∫mero total de bits 1 seja par (paridade par) ou √≠mpar (paridade √≠mpar). Detecta apenas um n√∫mero √≠mpar de erros de bits.
                        <ul>
                            <li><strong>Paridade de Bit √önico:</strong> Detecta um √∫nico erro de bit.</li>
                            <li><strong>Paridade Bidimensional:</strong> Organiza os dados em uma grade e adiciona bits de paridade para cada linha e coluna. Pode detectar e at√© corrigir erros de bit √∫nico.</li>
                        </ul>
                    </p>
                </li>
                <li>
                    <h4>Checksum (Soma de Verifica√ß√£o):</h4>
                    <p>
                        Usado principalmente na camada de transporte (UDP, TCP) e na camada de rede (IP, ICMP). Os bytes de dados s√£o tratados como n√∫meros, somados (complemento de um), e o resultado √© o checksum. No receptor, o checksum √© recalculado e comparado. Detecta a maioria dos erros, mas n√£o todos.
                    </p>
                </li>
                <li>
                    <h4>CRC (Cyclic Redundancy Check - Verifica√ß√£o de Redund√¢ncia C√≠clica):</h4>
                    <p>
                        √â a t√©cnica de detec√ß√£o de erro mais robusta e amplamente usada na camada de enlace (Ethernet, Wi-Fi, HDLC, ADSL). O remetente trata os bits como um n√∫mero bin√°rio e os divide por um "polin√¥mio gerador" padr√£o. O resto dessa divis√£o √© o CRC, que √© adicionado ao quadro. O receptor realiza a mesma divis√£o; se o resto for zero, presume-se que n√£o h√° erros. O CRC pode detectar todos os erros de rajada (burst errors) de comprimento menor ou igual ao grau do polin√¥mio, e uma alta porcentagem de erros maiores.
                    </p>
                </li>
            </ul>
        </section>

        <section id="protocolos-acesso-multiplo" class="chapter-section">
            <h3>Protocolos de Acesso M√∫ltiplo</h3>
            <p>
                Quando v√°rios n√≥s compartilham o mesmo meio de transmiss√£o ("canal de difus√£o"), como em uma rede Wi-Fi ou um antigo cabo Ethernet, eles precisam de um protocolo para coordenar o acesso ao meio, evitando que todos tentem transmitir ao mesmo tempo e causem colis√µes.
            </p>
            <ul>
                <li>
                    <h4>Classifica√ß√£o:</h4>
                    <ul>
                        <li>
                            <strong>Protocolos de Divis√£o de Canal:</strong> Dividem o meio em partes menores (tempo, frequ√™ncia, c√≥digo), permitindo acesso dedicado sem colis√µes.
                            <ul>
                                <li><strong>TDMA (Time Division Multiple Access):</strong> Cada n√≥ recebe um "slot" de tempo exclusivo para transmitir.</li>
                                <li><strong>FDMA (Frequency Division Multiple Access):</strong> Cada n√≥ recebe uma "frequ√™ncia" exclusiva para transmitir.</li>
                                <li><strong>CDMA (Code Division Multiple Access):</strong> Diferentes c√≥digos "espalham" os dados, permitindo que v√°rios usu√°rios transmitam simultaneamente em toda a banda de frequ√™ncia, mas usando c√≥digos diferentes para separa√ß√£o.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Protocolos de Acesso Aleat√≥rio:</strong> Os n√≥s transmitem sem coordena√ß√£o pr√©via. Colis√µes podem ocorrer, e s√£o resolvidas por mecanismos de detec√ß√£o e retransmiss√£o.
                            <ul>
                                <li>
                                    <strong>ALOHA:</strong>
                                    <ul>
                                        <li><strong>ALOHA Puro:</strong> Transmite imediatamente. Se houver colis√£o (n√£o recebe confirma√ß√£o), retransmite ap√≥s um tempo aleat√≥rio.</li>
                                        <li><strong>ALOHA Slotado:</strong> O tempo √© dividido em "slots". Os n√≥s s√≥ podem transmitir no in√≠cio de um slot, reduzindo a chance de colis√µes (elas ocorrem apenas se dois n√≥s iniciarem no mesmo slot).</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>CSMA (Carrier Sense Multiple Access - Acesso M√∫ltiplo por Sensoriamento de Portadora):</strong> Um n√≥ "ouve" o canal antes de transmitir. Se o canal estiver ocupado, espera.
                                    <ul>
                                        <li><strong>CSMA/CD (CSMA com Detec√ß√£o de Colis√£o):</strong> Usado em Ethernet com fio. O n√≥ escuta enquanto transmite. Se detectar uma colis√£o, para de transmitir, envia um sinal de "congestionamento" e retransmite ap√≥s um tempo aleat√≥rio. Isso economiza tempo, pois a transmiss√£o √© abortada logo ap√≥s a colis√£o.</li>
                                        <li><strong>CSMA/CA (CSMA com Preven√ß√£o de Colis√£o):</strong> Usado em redes sem fio (Wi-Fi). Devido ao problema de "terminal oculto" (n√≥s n√£o conseguem se ouvir mutuamente), a detec√ß√£o de colis√£o √© dif√≠cil. Em vez disso, tenta-se **evitar** colis√µes. Pode usar mensagens RTS/CTS (Request To Send / Clear To Send) para reservar o canal.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <strong>Protocolos de Tomada de Vez (Taking-Turns Protocols):</strong> Os n√≥s se revezam no acesso ao canal, como em uma fila organizada.
                            <ul>
                                <li><strong>Polling:</strong> Um n√≥ "mestre" pergunta a cada n√≥, em sequ√™ncia, se ele tem algo para enviar. Centralizado.</li>
                                <li><strong>Token Passing:</strong> Um "token" (ficha) circula entre os n√≥s. Apenas o n√≥ que possui o token pode transmitir. Descentralizado.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </section>

        <section id="enderecamento-mac-arp" class="chapter-section">
            <h3>Endere√ßamento de Camada de Enlace (MAC) e ARP</h3>
            <p>
                Cada adaptador de rede (como uma placa Ethernet ou Wi-Fi) em um hospedeiro ou roteador tem um endere√ßo √∫nico, chamado <strong>endere√ßo MAC (Media Access Control)</strong> ou endere√ßo f√≠sico.
            </p>
            <ul>
                <li>
                    <h4>Endere√ßos MAC (Endere√ßos F√≠sicos):</h4>
                    <p>
                        Um endere√ßo MAC √© um identificador de 6 bytes (48 bits), geralmente gravado na ROM da placa de rede pelo fabricante. √â representado em hexadecimal (ex: `00-1A-C2-00-5E-8C`). Ele √© √∫nico mundialmente.
                    </p>
                    <p>
                        Diferente dos endere√ßos IP (que s√£o l√≥gicos e podem mudar de rede para rede), o endere√ßo MAC √© fixo para o hardware. Quadros de camada de enlace s√£o endere√ßados usando endere√ßos MAC para entregas "salto a salto" na mesma rede local.
                    </p>
                </li>
                <li>
                    <h4>ARP (Address Resolution Protocol - Protocolo de Resolu√ß√£o de Endere√ßos):</h4>
                    <p>
                        O ARP √© um protocolo que opera na camada de enlace (ou entre enlace e rede) para traduzir um endere√ßo IP em um endere√ßo MAC correspondente na mesma sub-rede.
                    </p>
                    <p>
                        <strong>Como funciona:</strong>
                        <ol>
                            <li>Um hospedeiro (A) quer enviar um datagrama IP para outro hospedeiro (B) na mesma sub-rede, mas s√≥ conhece o IP de B.</li>
                            <li>A verifica seu cache ARP. Se n√£o encontrar o MAC de B, A envia uma mensagem de <strong>requisi√ß√£o ARP</strong> (broadcast) para todos os dispositivos na sub-rede, perguntando "Quem tem o IP X.X.X.X? Qual √© o seu MAC?".</li>
                            <li>O hospedeiro (B) com o IP X.X.X.X recebe a requisi√ß√£o e envia uma mensagem de <strong>resposta ARP</strong> (unicast) diretamente para A, contendo seu endere√ßo MAC.</li>
                            <li>A recebe a resposta, armazena o mapeamento IP-MAC em seu cache ARP (que expira ap√≥s um tempo) e pode ent√£o encapsular o datagrama IP em um quadro com o endere√ßo MAC de B para envi√°-lo.</li>
                        </ol>
                    </p>
                    <p>
                        Para enviar um datagrama IP para um hospedeiro em <strong>outra sub-rede</strong>, o hospedeiro remetente usa o ARP para descobrir o endere√ßo MAC do seu roteador de primeira parada (gateway padr√£o). O datagrama √© ent√£o enviado para o roteador, que se encarrega de rote√°-lo para a rede de destino.
                    </p>
                </li>
            </ul>
        </section>

        <section id="ethernet" class="chapter-section">
            <h3>Ethernet</h3>
            <p>
                A <strong>Ethernet</strong> √© a tecnologia de rede local (LAN) com fio mais dominante no mundo. Ela √© um padr√£o da IEEE (Instituto de Engenheiros Eletricistas e Eletr√¥nicos) sob a fam√≠lia <strong>IEEE 802.3</strong>.
            </p>
            <ul>
                <li>
                    <h4>Caracter√≠sticas da Ethernet:</h4>
                    <ul>
                        <li><strong>N√£o Confi√°vel:</strong> A Ethernet (e seus ancestrais) n√£o fornece servi√ßo de transfer√™ncia confi√°vel na camada de enlace. Se um erro √© detectado em um quadro, o quadro √© simplesmente descartado, e a recupera√ß√£o √© deixada para as camadas superiores (TCP).</li>
                        <li><strong>Sem Conex√£o:</strong> N√£o h√° estabelecimento de conex√£o pr√©via entre os adaptadores antes de enviar um quadro.</li>
                        <li><strong>CSMA/CD:</strong> Historicamente, a Ethernet usava o protocolo de acesso m√∫ltiplo CSMA/CD em seus segmentos de barramento compartilhados (10Base-T). Hoje, a maioria das redes Ethernet usa comutadores, eliminando o problema de colis√µes no n√≠vel do segmento.</li>
                    </ul>
                </li>
                <li>
                    <h4>Estrutura do Quadro Ethernet:</h4>
                    <p>
                        Um quadro Ethernet (datagrama IP encapsulado) tem a seguinte estrutura:
                        <pre>
+----------+------------+------------+------+-----+--------+----------+
| Pre√¢mbulo| End. Dest. | End. Orig. | Tipo | Dados | CRC    |
| (8 bytes)| (6 bytes)  | (6 bytes)  | (2)  | (46-1500) | (4 bytes)|
+----------+------------+------------+------+-----+--------+----------+
                        </pre>
                        <ul>
                            <li><strong>Pre√¢mbulo:</strong> Sete bytes de `10101010` seguidos por um byte `10101011`. Usado para sincroniza√ß√£o de clock do receptor.</li>
                            <li><strong>Endere√ßo de Destino (MAC):</strong> Endere√ßo MAC do adaptador de destino (se unicast) ou broadcast (`FF-FF-FF-FF-FF-FF`).</li>
                            <li><strong>Endere√ßo de Origem (MAC):</strong> Endere√ßo MAC do adaptador de origem.</li>
                            <li><strong>Tipo:</strong> Indica o protocolo da camada superior para o qual o datagrama deve ser entregue (ex: IP).</li>
                            <li><strong>Dados:</strong> O datagrama IP (payload), de 46 a 1500 bytes.</li>
                            <li><strong>CRC:</strong> Verifica√ß√£o de Redund√¢ncia C√≠clica para detec√ß√£o de erros.</li>
                        </ul>
                    </p>
                </li>
                <li>
                    <h4>Ethernet em Meios Compartilhados: Hubs e Colis√µes:</h4>
                    <p>
                        Redes Ethernet antigas usavam **hubs**, que s√£o dispositivos de camada f√≠sica. Todos os dispositivos conectados a um hub compartilham um √∫nico dom√≠nio de colis√£o (ou seja, se dois transmitirem ao mesmo tempo, h√° colis√£o). O CSMA/CD era essencial nesse cen√°rio. Hoje, hubs s√£o raros.
                    </p>
                </li>
                <li>
                    <h4>Ethernet Comutado (Switched Ethernet):</h4>
                    <p>
                        A Ethernet moderna usa **comutadores (switches)**, que operam na camada de enlace. Um comutador Ethernet elimina colis√µes, pois ele cria um dom√≠nio de colis√£o separado para cada porta. Ele aprende dinamicamente os endere√ßos MAC dos dispositivos conectados √†s suas portas e encaminha os quadros seletivamente para a porta correta, em vez de difundir para todas as portas como um hub. Isso melhora muito a performance da rede.
                    </p>
                </li>
            </ul>
        </section>

        <section id="comutadores" class="chapter-section">
            <h3>Comutadores (Switches): Conectando Redes Locais</h3>
            <p>
                Os comutadores (switches) s√£o dispositivos de rede de camada de enlace (Camada 2 do OSI) que interconectam m√∫ltiplos dispositivos e segmentos de rede em uma LAN. Eles s√£o muito mais "inteligentes" que os hubs.
            </p>
            <ul>
                <li>
                    <h4>Repasse e Aprendizado de Comutadores:</h4>
                    <p>
                        Um comutador n√£o precisa de configura√ß√£o manual para saber para onde enviar os quadros. Ele aprende dinamicamente a localiza√ß√£o dos dispositivos conectados a ele.
                    </p>
                    <ul>
                        <li><strong>Tabela de Comuta√ß√£o:</strong> Um comutador mant√©m uma <strong>tabela de comuta√ß√£o</strong> (tamb√©m conhecida como tabela de endere√ßos MAC ou tabela de encaminhamento) que mapeia endere√ßos MAC para portas espec√≠ficas e um tempo de validade.</li>
                        <li><strong>Aprendizado Autom√°tico:</strong> Quando um comutador recebe um quadro, ele inspeciona o endere√ßo MAC de origem do quadro. Se esse endere√ßo n√£o estiver em sua tabela, ele o adiciona (associando-o √† porta de entrada). Isso √© o <strong>aprendizado</strong>.</li>
                        <li><strong>Encaminhamento (Repasse):</strong> Quando um comutador recebe um quadro com um endere√ßo MAC de destino, ele consulta sua tabela:
                            <ul>
                                <li>Se o endere√ßo de destino estiver na tabela e associado a uma porta diferente da de entrada, o quadro √© enviado apenas para essa porta espec√≠fica.</li>
                                <li>Se o endere√ßo de destino estiver na mesma porta de entrada (ou seja, o destino est√° no mesmo segmento que a origem), o quadro √© descartado.</li>
                                <li>Se o endere√ßo de destino n√£o estiver na tabela, ou se for um endere√ßo de broadcast (`FF-FF-FF-FF-FF-FF`), o quadro √© enviado para <strong>todas as portas</strong>, exceto a de entrada (isso √© chamado de <strong>flooding</strong>). O dispositivo de destino responder√°, e o comutador aprender√° sua localiza√ß√£o na pr√≥xima vez.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <h4>Comutadores vs. Roteadores:</h4>
                    <p>
                        Embora ambos encaminhem pacotes, comutadores e roteadores operam em camadas diferentes e t√™m objetivos distintos:
                        <ul>
                            <li><strong>Comutadores (Camada 2):</strong>
                                <ul>
                                    <li>Operam na camada de enlace (endere√ßos MAC).</li>
                                    <li>Repassam quadros entre interfaces na mesma LAN.</li>
                                    <li>N√£o alteram os endere√ßos MAC dos quadros.</li>
                                    <li>Aprendem dinamicamente as tabelas de comuta√ß√£o.</li>
                                    <li>N√£o impedem a propaga√ß√£o de broadcasts.</li>
                                    <li>Conhecidos por serem "plug-and-play" e r√°pidos no encaminhamento.</li>
                                </ul>
                            </li>
                            <li><strong>Roteadores (Camada 3):</strong>
                                <ul>
                                    <li>Operam na camada de rede (endere√ßos IP).</li>
                                    <li>Roteiam datagramas entre diferentes sub-redes/LANs.</li>
                                    <li>Alteram endere√ßos MAC (e podem alterar IPs) ao repassar datagramas.</li>
                                    <li>Constroem tabelas de roteamento usando algoritmos e protocolos de roteamento (RIP, OSPF, BGP).</li>
                                    <li>Interrompem a propaga√ß√£o de broadcasts (cada interface de roteador √© um dom√≠nio de broadcast).</li>
                                    <li>Mais complexos, mais lentos no repasse (historicamente), mas mais vers√°teis.</li>
                                </ul>
                            </li>
                        </ul>
                    </p>
                </li>
            </ul>
        </section>

        <section id="vlans" class="chapter-section">
            <h3>Redes Locais Virtuais (VLANs)</h3>
            <p>
                Uma <strong>VLAN (Virtual Local Area Network)</strong> permite que os administradores de rede particionem uma √∫nica rede f√≠sica (composta por um ou mais comutadores) em m√∫ltiplas redes locais virtuais. Isso significa que dispositivos conectados ao mesmo comutador f√≠sico podem estar em diferentes VLANs, e dispositivos em diferentes comutadores f√≠sicos podem estar na mesma VLAN.
            </p>
            <ul>
                <li>
                    <strong>Prop√≥sitos da VLAN:</strong>
                    <ul>
                        <li><strong>Isolamento de Broadcast:</strong> Cada VLAN √© um dom√≠nio de broadcast separado, o que melhora a seguran√ßa e a performance ao reduzir a propaga√ß√£o de tr√°fego desnecess√°rio.</li>
                        <li><strong>Seguran√ßa:</strong> Separa√ß√£o de departamentos (ex: RH, Finan√ßas) ou tipos de tr√°fego (dados, voz, v√≠deo).</li>
                        <li><strong>Gerenciamento Flex√≠vel:</strong> Usu√°rios podem ser movidos para diferentes VLANs (e, portanto, diferentes sub-redes IP) sem precisar mudar o cabeamento f√≠sico.</li>
                    </ul>
                </li>
                <li>
                    <strong>Comutadores de Tronco (Trunking Switches):</strong>
                    <p>
                        Para que quadros de diferentes VLANs possam viajar entre comutadores, √© usado um enlace de "tronco" (trunk link). O padr√£o <strong>IEEE 802.1Q</strong> especifica como os comutadores adicionam uma tag de VLAN (de 12 bits) aos quadros Ethernet para identificar a qual VLAN o quadro pertence. Isso permite que um √∫nico enlace f√≠sico transporte o tr√°fego de m√∫ltiplas VLANs.
                    </p>
                </li>
                <li>
                    <strong>Roteamento Inter-VLAN:</strong>
                    <p>
                        Para que dispositivos em diferentes VLANs possam se comunicar, o tr√°fego deve passar por um roteador. O roteador tem interfaces (f√≠sicas ou l√≥gicas - "router-on-a-stick") configuradas para cada VLAN.
                    </p>
                </li>
            </ul>
        </section>

        <section id="mpls" class="chapter-section">
            <h3>MPLS (Multiprotocol Label Switching)</h3>
            <p>
                O <strong>MPLS (Multiprotocol Label Switching)</strong> √© uma t√©cnica de encaminhamento de pacotes que opera entre a camada de rede (IP) e a camada de enlace. Ele foi desenvolvido para combinar a flexibilidade do roteamento IP com a velocidade do encaminhamento baseado em circuitos, e para suportar o roteamento baseado em pol√≠ticas de tr√°fego (engenharia de tr√°fego).
            </p>
            <ul>
                <li>
                    <h4>Princ√≠pios do MPLS:</h4>
                    <p>
                        No MPLS, os pacotes IP s√£o "embrulhados" com um pequeno cabe√ßalho MPLS contendo um <strong>r√≥tulo (label)</strong>. O encaminhamento dos pacotes MPLS √© feito com base apenas nesse r√≥tulo, em vez de inspecionar o endere√ßo IP de destino.
                    </p>
                    <ul>
                        <li><strong>Roteadores de Borda MPLS (Label Edge Routers - LERs):</strong> Na entrada de uma rede MPLS, o LER adiciona um r√≥tulo ao pacote IP, encaminhando-o para um caminho de r√≥tulo. Na sa√≠da, ele remove o r√≥tulo e repassa o pacote IP normal.</li>
                        <li><strong>Roteadores de R√≥tulo (Label Switching Routers - LSRs):</strong> No interior da rede MPLS, os LSRs encaminham pacotes simplesmente trocando o r√≥tulo de entrada por um r√≥tulo de sa√≠da, sem precisar examinar o cabe√ßalho IP. Isso √© muito mais r√°pido que uma consulta √† tabela de roteamento IP.</li>
                    </ul>
                </li>
                <li>
                    <h4>Caminhos de R√≥tulo (LSPs - Label Switched Paths):</h4>
                    <p>
                        Os LSPs s√£o caminhos pr√©-determinados e unidirecionais atrav√©s da rede MPLS, pelos quais os pacotes com um determinado r√≥tulo viajar√£o. Eles s√£o estabelecidos antes da chegada dos pacotes de dados.
                    </p>
                </li>
                <li>
                    <h4>Vantagens do MPLS:</h4>
                    <ul>
                        <li><strong>Encaminhamento Mais R√°pido:</strong> A troca de r√≥tulos √© mais r√°pida que a consulta de rotas IP complexas.</li>
                        <li><strong>Engenharia de Tr√°fego:</strong> Permite desviar tr√°fego de um caminho congestionado para outro, mesmo que n√£o seja o "caminho mais curto" baseado apenas no IP.</li>
                        <li><strong>QoS (Qualidade de Servi√ßo):</strong> Permite que diferentes tipos de tr√°fego (voz, v√≠deo) recebam tratamentos diferenciados e garantias.</li>
                        <li><strong>Suporte a VPNs de Camada 3:</strong> Facilita a implementa√ß√£o de VPNs em larga escala.</li>
                    </ul>
                </li>
            </ul>
        </section>

        <section id="resumo-capitulo" class="chapter-section">
            <h3>Resumo do Cap√≠tulo</h3>
            <p>
                Neste cap√≠tulo, exploramos em profundidade a <strong>Camada de Enlace</strong>, a "ponte" essencial para a comunica√ß√£o de dados entre n√≥s adjacentes. Come√ßamos com os servi√ßos que ela oferece, como enquadramento, acesso ao meio, detec√ß√£o/corre√ß√£o de erros e transfer√™ncia confi√°vel.
            </p>
            <p>
                Discutimos as importantes t√©cnicas de <strong>detec√ß√£o e corre√ß√£o de erros</strong> (paridade, checksum, CRC) que garantem a integridade dos dados em um enlace. Aprofundamos nos <strong>protocolos de acesso m√∫ltiplo</strong> (ALOHA, CSMA/CD, CSMA/CA), essenciais para compartilhar um mesmo meio, e diferenciamos a intelig√™ncia por tr√°s dos <strong>endere√ßos MAC</strong> e do protocolo <strong>ARP</strong> para resolu√ß√£o de endere√ßos.
            </p>
            <p>
                Vimos a onipresen√ßa da <strong>Ethernet</strong> e como ela evoluiu de redes baseadas em hubs para redes modernas baseadas em <strong>comutadores (switches)</strong>, que aprendem dinamicamente e eliminam colis√µes. Finalmente, abordamos conceitos mais avan√ßados como as <strong>VLANs</strong>, que permitem a segmenta√ß√£o l√≥gica de redes, e o <strong>MPLS</strong>, uma tecnologia que otimiza o encaminhamento e a engenharia de tr√°fego em grandes redes.
            </p>
            <p>
                A camada de enlace, embora opere em um n√≠vel "local", √© fundamental para a performance e confiabilidade das redes modernas. Ela complementa a camada de rede, fornecendo o "transporte rodovi√°rio" eficiente para que os pacotes cheguem ao seu destino final. No pr√≥ximo cap√≠tulo, exploraremos as redes sem fio e redes m√≥veis.
            </p>
        </section>

        <section id="atividades" class="chapter-section">
            <h3>Atividades de Aprendizagem</h3>
            <p>Teste seus conhecimentos sobre o Cap√≠tulo 5 com as seguintes perguntas de m√∫ltipla escolha:</p>

            <!-- Quest√£o 1 -->
            <div class="question-block">
                <p>1. Qual √© a principal fun√ß√£o da Camada de Enlace em uma rede de computadores?</p>
                <label>
                    <input type="radio" name="q1_ch5" value="a"> A) Roteamento de pacotes entre diferentes redes IP.
                </label>
                <label>
                    <input type="radio" name="q1_ch5" value="b"> B) Fornecer comunica√ß√£o l√≥gica entre processos em sistemas finais.
                </label>
                <label>
                    <input type="radio" name="q1_ch5" value="c"> C) Transferir dados de um n√≥ para um n√≥ adjacente ao longo de um √∫nico enlace.
                </label>
                <label>
                    <input type="radio" name="q1_ch5" value="d"> D) Gerenciar aplica√ß√µes de rede como HTTP e FTP.
                </label>
                <button class="check-button" onclick="checkAnswer('q1_ch5', 'c', 'feedback1_ch5')">Verificar Resposta</button>
                <div class="feedback" id="feedback1_ch5"></div>
            </div>

            <!-- Quest√£o 2 -->
            <div class="question-block">
                <p>2. Qual t√©cnica de detec√ß√£o de erro √© mais robusta e amplamente utilizada na camada de enlace (ex: Ethernet, Wi-Fi), tratando os bits como um n√∫mero bin√°rio e usando um polin√¥mio gerador?</p>
                <label>
                    <input type="radio" name="q2_ch5" value="a"> A) Bits de Paridade
                </label>
                <label>
                    <input type="radio" name="q2_ch5" value="b"> B) Checksum
                </label>
                <label>
                    <input type="radio" name="q2_ch5" value="c"> C) CRC (Cyclic Redundancy Check)
                </label>
                <label>
                    <input type="radio" name="q2_ch5" value="d"> D) N√∫meros de Sequ√™ncia
                </label>
                <button class="check-button" onclick="checkAnswer('q2_ch5', 'c', 'feedback2_ch5')">Verificar Resposta</button>
                <div class="feedback" id="feedback2_ch5"></div>
            </div>

            <!-- Quest√£o 3 -->
            <div class="question-block">
                <p>3. Qual protocolo de acesso m√∫ltiplo √© usado em redes Wi-Fi e tenta **evitar** colis√µes devido ao problema de "terminal oculto"?</p>
                <label>
                    <input type="radio" name="q3_ch5" value="a"> A) CSMA/CD
                </label>
                <label>
                    <input type="radio" name="q3_ch5" value="b"> B) ALOHA Slotado
                </label>
                <label>
                    <input type="radio" name="q3_ch5" value="c"> C) CSMA/CA
                </label>
                <label>
                    <input type="radio" name="q3_ch5" value="d"> D) TDMA
                </label>
                <button class="check-button" onclick="checkAnswer('q3_ch5', 'c', 'feedback3_ch5')">Verificar Resposta</button>
                <div class="feedback" id="feedback3_ch5"></div>
            </div>

            <!-- Quest√£o 4 -->
            <div class="question-block">
                <p>4. O que √© um endere√ßo MAC?</p>
                <label>
                    <input type="radio" name="q4_ch5" value="a"> A) Um identificador l√≥gico de 32 bits para hospedeiros em redes IP.
                </label>
                <label>
                    <input type="radio" name="q4_ch5" value="b"> B) Um identificador de 6 bytes (48 bits) gravado na ROM da placa de rede, √∫nico mundialmente.
                </label>
                <label>
                    <input type="radio" name="q4_ch5" value="c"> C) O nome de dom√≠nio de um servidor web.
                </label>
                <label>
                    <input type="radio" name="q4_ch5" value="d"> D) Um n√∫mero de porta usado por protocolos de transporte.
                </label>
                <button class="check-button" onclick="checkAnswer('q4_ch5', 'b', 'feedback4_ch5')">Verificar Resposta</button>
                <div class="feedback" id="feedback4_ch5"></div>
            </div>

            <!-- Quest√£o 5 -->
            <div class="question-block">
                <p>5. Qual tecnologia permite que os administradores de rede particionem uma √∫nica rede f√≠sica (comutadores) em m√∫ltiplas redes locais virtuais, isolando dom√≠nios de broadcast?</p>
                <label>
                    <input type="radio" name="q5_ch5" value="a"> A) NAT (Network Address Translation)
                </label>
                <label>
                    <input type="radio" name="q5_ch5" value="b"> B) MPLS (Multiprotocol Label Switching)
                </label>
                <label>
                    <input type="radio" name="q5_ch5" value="c"> C) VLANs (Virtual Local Area Networks)
                </label>
                <label>
                    <input type="radio" name="q5_ch5" value="d"> D) DHCP (Dynamic Host Configuration Protocol)
                </label>
                <button class="check-button" onclick="checkAnswer('q5_ch5', 'c', 'feedback5_ch5')">Verificar Resposta</button>
                <div class="feedback" id="feedback5_ch5"></div>
            </div>
        </section>

        <div class="chapter-navigation-buttons">
            <a href="capitulo4.html" class="back-button">‚Üê Cap√≠tulo Anterior</a>
            <a href="capitulo6.html" class="back-button">Pr√≥ximo Cap√≠tulo ‚Üí</a>
        </div>
    </main>

 
    <footer id="contato">
        <div class="container">
            <p>&copy; 2025 Desvendando as Redes. Todos os direitos reservados.</p>
            <div class="social-links">
                <a href="#">Facebook</a>
                <a href="#">Twitter</a>
                <a href="#">LinkedIn</a>
            </div>
        </div>
    </footer>

    <!-- Script para verificar as respostas -->
    <script>
        function checkAnswer(questionName, correctAnswer, feedbackId) {
            const selectedOption = document.querySelector(`input[name="${questionName}"]:checked`);
            const feedbackElement = document.getElementById(feedbackId);

            if (selectedOption) {
                if (selectedOption.value === correctAnswer) {
                    feedbackElement.textContent = "Correto! üéâ";
                    feedbackElement.className = "feedback correct";
                } else {
                    feedbackElement.textContent = "Incorreto. Tente novamente!";
                    feedbackElement.className = "feedback incorrect";
                }
            } else {
                feedbackElement.textContent = "Por favor, selecione uma op√ß√£o.";
                feedbackElement.className = "feedback incorrect";
            }
        }
    </script>
    <!-- Vincula o arquivo JavaScript externo (mesmo que vazio, mant√©m a estrutura) -->
    <script src="script.js"></script>
</body>
</html>
